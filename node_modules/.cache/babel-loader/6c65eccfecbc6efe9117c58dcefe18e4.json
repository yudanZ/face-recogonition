{"ast":null,"code":"const axios = require(\"axios\");\n\nconst {\n  findAppropriateUrl\n} = require(\"./methods_info\");\n/**\n * This recursively goes through the object/array and serialized any \"base64\" field that has Buffer value to a BASE64\n * string.\n */\n\n\nfunction stringifyBase64(obj) {\n  if (obj.constructor === Array) {\n    return obj.map(stringifyBase64);\n  } else if (obj.constructor === Object) {\n    const processedObject = {};\n\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        if (key === \"base64\") {\n          if (Buffer.isBuffer(obj[key])) {\n            processedObject[key] = obj[key].toString(\"base64\");\n          } else if (typeof obj[key] === 'string' || obj[key] instanceof String) {\n            // Here we assume the value is already in BASE64.\n            processedObject[key] = obj[key];\n          } else {\n            throw new Error(\"base64 has incorrect type, only Buffer and string (base64) are supported.\");\n          }\n        } else {\n          processedObject[key] = stringifyBase64(obj[key]);\n        }\n      }\n    }\n\n    return processedObject;\n  } else {\n    return obj;\n  }\n}\n\nfunction prepareGetParameters(request) {\n  let encodedParameters = {};\n\n  for (const key in request) {\n    if (request.hasOwnProperty(key)) {\n      let value = request[key];\n\n      if (value.constructor == Object) {\n        let subObj = prepareGetParameters(value);\n\n        for (const subKey in subObj) {\n          if (subObj.hasOwnProperty(subKey)) {\n            const subValue = subObj[subKey];\n            encodedParameters[key + \".\" + subKey] = subValue;\n          }\n        }\n      } else {\n        encodedParameters[key] = String(value);\n      }\n    }\n  }\n\n  return encodedParameters;\n}\n\nfunction encodeGetParameters(request) {\n  let url = \"\";\n  const additionalParametersObject = prepareGetParameters(request);\n\n  if (Object.keys(additionalParametersObject).length > 0) {\n    let p = [];\n\n    for (const k in additionalParametersObject) {\n      p.push(k + \"=\" + additionalParametersObject[k]);\n    }\n\n    url = \"?\" + p.join(\"&\");\n  }\n\n  return url;\n}\n\nclass CustomCall {\n  constructor(method) {\n    this.baseUrl = \"https://api.clarifai.com\";\n    const parts = method.split(\"/\");\n    this.methodName = parts[parts.length - 1];\n  }\n\n  sendMetadata(metadata) {\n    let headers = {};\n\n    for (const field of metadata.internalRepr) {\n      headers[field[0]] = field[1][0];\n    }\n\n    this.headers = headers;\n  }\n\n  write(writeObj) {\n    this.request = stringifyBase64(writeObj.message);\n    const possibleParams = Object.keys(this.request);\n    const r = findAppropriateUrl(this.methodName, this.request);\n\n    if (!r) {\n      throw new Error(\"Unknown method: \" + method);\n    }\n\n    this.subUrl = r.subUrl;\n    this.httpMethod = r.httpMethod;\n\n    for (const field of r.usedFields) {\n      delete this.request[field];\n    }\n  }\n\n  end() {}\n\n  on(eventType, callback) {\n    const status = {\n      code: 0\n    };\n    const errorStatus = {\n      code: 1\n    };\n\n    if (eventType === \"data\") {\n      this.dataCallback = callback;\n    } else if (eventType === \"status\") {\n      if (this.statusAlreadyGotten) {\n        return;\n      }\n\n      this.statusAlreadyGotten = true;\n      let url = this.baseUrl + this.subUrl;\n      let data;\n\n      if (this.httpMethod === \"get\") {\n        data = null;\n        url += encodeGetParameters(this.request);\n      } else {\n        data = this.request;\n      }\n\n      axios({\n        method: this.httpMethod,\n        url: url,\n        data: data,\n        headers: this.headers\n      }).then(response => {\n        this.dataCallback(response.data);\n        callback(status);\n      }).catch(error => {\n        if (error.response && error.response.data) {\n          this.dataCallback(error.response.data);\n          callback(status);\n        } else {\n          this.dataCallback(JSON.stringify(error));\n          callback(errorStatus);\n        }\n      });\n    }\n  }\n\n}\n\nclass CustomChannel {\n  createCall(method, deadline, host, parentCall, propagateFlags) {\n    return new CustomCall(method);\n  }\n\n}\n\nclass ClarifaiChannel {\n  static makeJsonChannel() {\n    return new CustomChannel();\n  }\n\n}\n\nmodule.exports = {\n  ClarifaiChannel\n};","map":{"version":3,"sources":["E:/yudan/facerecognition/node_modules/clarifai-nodejs-grpc/src/custom-json-channel.js"],"names":["axios","require","findAppropriateUrl","stringifyBase64","obj","constructor","Array","map","Object","processedObject","key","hasOwnProperty","Buffer","isBuffer","toString","String","Error","prepareGetParameters","request","encodedParameters","value","subObj","subKey","subValue","encodeGetParameters","url","additionalParametersObject","keys","length","p","k","push","join","CustomCall","method","baseUrl","parts","split","methodName","sendMetadata","metadata","headers","field","internalRepr","write","writeObj","message","possibleParams","r","subUrl","httpMethod","usedFields","end","on","eventType","callback","status","code","errorStatus","dataCallback","statusAlreadyGotten","data","then","response","catch","error","JSON","stringify","CustomChannel","createCall","deadline","host","parentCall","propagateFlags","ClarifaiChannel","makeJsonChannel","module","exports"],"mappings":"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","sourcesContent":["const axios = require(\"axios\");\nconst {findAppropriateUrl} = require(\"./methods_info\");\n\n/**\n * This recursively goes through the object/array and serialized any \"base64\" field that has Buffer value to a BASE64\n * string.\n */\nfunction stringifyBase64(obj) {\n    if (obj.constructor === Array) {\n        return obj.map(stringifyBase64);\n    } else if (obj.constructor === Object) {\n        const processedObject = {}\n        for (const key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                if (key === \"base64\") {\n                    if (Buffer.isBuffer(obj[key])) {\n                        processedObject[key] = obj[key].toString(\"base64\");\n                    } else if (typeof obj[key] === 'string' || obj[key] instanceof String) {\n                        // Here we assume the value is already in BASE64.\n                        processedObject[key] = obj[key];\n                    } else {\n                        throw new Error(\"base64 has incorrect type, only Buffer and string (base64) are supported.\");\n                    }\n                } else {\n                    processedObject[key] = stringifyBase64(obj[key]);\n                }\n            }\n        }\n        return processedObject;\n    } else {\n        return obj;\n    }\n}\n\nfunction prepareGetParameters(request) {\n    let encodedParameters = {};\n    for (const key in request) {\n        if (request.hasOwnProperty(key)) {\n            let value = request[key];\n\n            if (value.constructor == Object) {\n                let subObj = prepareGetParameters(value);\n                for (const subKey in subObj) {\n                    if (subObj.hasOwnProperty(subKey)) {\n                        const subValue = subObj[subKey];\n                        encodedParameters[key + \".\" + subKey] = subValue;\n                    }\n                }\n            } else {\n                encodedParameters[key] = String(value);\n            }\n        }\n    }\n    return encodedParameters;\n}\n\nfunction encodeGetParameters(request) {\n    let url = \"\";\n\n    const additionalParametersObject = prepareGetParameters(request);\n    if (Object.keys(additionalParametersObject).length > 0) {\n        let p = [];\n        for (const k in additionalParametersObject) {\n            p.push(k + \"=\" + additionalParametersObject[k]);\n        }\n        url = \"?\" + p.join(\"&\");\n    }\n    return url;\n}\n\nclass CustomCall {\n    constructor(method) {\n        this.baseUrl = \"https://api.clarifai.com\";\n\n        const parts = method.split(\"/\");\n        this.methodName = parts[parts.length - 1];\n    }\n\n    sendMetadata(metadata) {\n        let headers = {};\n        for (const field of metadata.internalRepr) {\n            headers[field[0]] = field[1][0];\n        }\n        this.headers = headers;\n    }\n\n    write(writeObj) {\n        this.request = stringifyBase64(writeObj.message);\n\n        const possibleParams = Object.keys(this.request);\n\n        const r = findAppropriateUrl(this.methodName, this.request);\n        if (!r) {\n            throw new Error(\"Unknown method: \" + method);\n        }\n\n        this.subUrl = r.subUrl;\n        this.httpMethod = r.httpMethod;\n        for (const field of r.usedFields) {\n            delete this.request[field];\n        }\n    }\n\n    end() {\n    }\n\n    on(eventType, callback) {\n        const status = {code: 0};\n        const errorStatus = {code: 1};\n\n        if (eventType === \"data\") {\n            this.dataCallback = callback;\n\n        } else if (eventType === \"status\") {\n            if (this.statusAlreadyGotten) { return; }\n            this.statusAlreadyGotten = true;\n\n            let url = this.baseUrl + this.subUrl;\n            let data;\n            if (this.httpMethod === \"get\") {\n                data = null;\n                url += encodeGetParameters(this.request);\n            } else {\n                data = this.request;\n            }\n\n            axios({\n                method: this.httpMethod,\n                url: url,\n                data: data,\n                headers: this.headers,\n            }).then((response) => {\n                this.dataCallback(response.data);\n                callback(status);\n            }).catch((error) => {\n                if (error.response && error.response.data) {\n                    this.dataCallback(error.response.data);\n                    callback(status);\n                } else {\n                    this.dataCallback(JSON.stringify(error));\n                    callback(errorStatus);\n                }\n            });\n        }\n    }\n}\n\n\n\nclass CustomChannel {\n    createCall(method, deadline, host, parentCall, propagateFlags) {\n        return new CustomCall(method);\n    }\n}\n\nclass ClarifaiChannel {\n    static makeJsonChannel() {\n        return new CustomChannel();\n    }\n}\n\nmodule.exports = {ClarifaiChannel};\n"]},"metadata":{},"sourceType":"script"}