{"ast":null,"code":"const Protobuf = require(\"protobufjs\");\n\nconst PROTO_PATH = __dirname + \"/../proto\";\nconst filenames = [PROTO_PATH + \"/clarifai/api/status/status_code.proto\", PROTO_PATH + \"/clarifai/api/status/status.proto\", PROTO_PATH + \"/clarifai/api/resources.proto\", PROTO_PATH + \"/clarifai/api/service_processed.proto\"];\nlet options = {\n  keepCase: true,\n  longs: String,\n  enums: Number,\n  defaults: false,\n  oneofs: true\n};\n/*\n * This function extracts the app_id and user_id values from the request object, or returns an empty array.\n */\n\nfunction readAppIdAndUserId(request) {\n  if (request.constructor === Array) {\n    for (const e of request) {\n      const ids = readAppIdAndUserId(e);\n\n      if (ids.length === 2) {\n        return ids;\n      }\n    }\n  } else if (request.constructor === Object) {\n    for (const key in request) {\n      if (!request.hasOwnProperty(key)) continue;\n      const value = request[key];\n\n      if (key === \"apps\") {\n        if (value.length === 1) {\n          return [value[0][\"id\"], value[0][\"user_id\"]];\n        } else if (value.length === 0) {\n          return [];\n        } else {\n          throw new Error(\"The request supports specifying only one app.\");\n        }\n      } else if (key === \"metadata\") {\n        continue;\n      }\n\n      const ids = readAppIdAndUserId(value);\n\n      if (ids.length === 2) {\n        return ids;\n      }\n    }\n  }\n\n  return [];\n}\n\nfunction findAppropriateUrl(name, request) {\n  let bestMatchUrl = undefined;\n  let bestMatchCount = -1;\n  let allFields = [];\n  let bestMatchUrlFields = undefined;\n  const methodsInfo = extractMethodsInfo(filenames, options);\n  const info = methodsInfo[name];\n\n  if (!info) {\n    return undefined;\n  }\n\n  const ids = readAppIdAndUserId(request);\n  let appId;\n  let userId;\n\n  if (ids.length === 2) {\n    appId = ids[0];\n    userId = ids[1];\n  } else {\n    appId = null;\n    userId = null;\n  }\n\n  for (const availableUrl of info.availableUrls) {\n    let allArgumentsTranslated = true;\n    let url = availableUrl;\n    let count = 0;\n    let urlFields = extractRequiredUrlParameters(url);\n\n    for (const field of urlFields) {\n      const parts = field.split(\".\");\n      const fieldName = parts[parts.length - 1];\n      let fieldValue;\n\n      if (fieldName === \"app_id\") {\n        fieldValue = appId;\n      } else if (fieldName === \"user_id\") {\n        if (userId != null) {\n          fieldValue = userId;\n        } else {\n          fieldValue = \"me\";\n        }\n      } else {\n        fieldValue = request[fieldName];\n      }\n\n      if (!fieldValue) {\n        allArgumentsTranslated = false;\n        break;\n      }\n\n      count++;\n      url = url.replace(\"{\" + field + \"}\", fieldValue);\n    }\n\n    allFields.push(info.availableUrls);\n\n    if (allArgumentsTranslated) {\n      if (bestMatchCount < count) {\n        bestMatchUrl = url;\n        bestMatchUrlFields = urlFields;\n        bestMatchCount = count;\n      }\n    }\n  }\n\n  if (!bestMatchUrl) {\n    throw new Error(\"You must set one case of the following fields in your request proto: \" + allFields);\n  }\n\n  return {\n    \"httpMethod\": info[\"httpMethod\"],\n    \"subUrl\": bestMatchUrl,\n    \"usedFields\": bestMatchUrlFields\n  };\n}\n\nfunction extractRequiredUrlParameters(url) {\n  const openings = [];\n  const closes = [];\n\n  for (let i = 0; i < url.length; i++) {\n    if (url[i] === \"{\") openings.push(i);\n    if (url[i] === \"}\") closes.push(i);\n  }\n\n  const fields = [];\n\n  for (let i = 0; i < openings.length; i++) {\n    fields.push(url.substring(openings[i] + 1, closes[i]));\n  }\n\n  return fields;\n}\n\nfunction extractMethodsInfo(filenames, options) {\n  const methodsInfo = {};\n  const root = new Protobuf.Root();\n  const loadedRoot = root.loadSync(filenames, options);\n  const methods = loadedRoot.nested.clarifai.nested.api.V2.methods;\n\n  for (const methodName in methods) {\n    if (!methods.hasOwnProperty(methodName)) continue;\n    const methodInfo = {\n      httpMethod: undefined,\n      availableUrls: []\n    };\n    const options = methods[methodName].options;\n\n    for (const fieldName in options) {\n      if (!fieldName.startsWith(\"(google.api.http).\")) continue;\n\n      if (![\".get\", \".post\", \".patch\", \".delete\"].some(s => fieldName.endsWith(s))) {\n        // This field doesn't describe a HTTP endpoint.\n        continue;\n      }\n\n      const fieldNameParts = fieldName.split(\".\");\n      methodInfo.httpMethod = fieldNameParts[fieldNameParts.length - 1];\n      methodInfo.availableUrls.push(options[fieldName]);\n    }\n\n    if (methodInfo.httpMethod) {\n      methodsInfo[methodName] = methodInfo;\n    } else {\n      console.log(\"Warning, strange method info: \" + methodInfo);\n    }\n  }\n\n  return methodsInfo;\n}\n\nmodule.exports = {\n  findAppropriateUrl\n};","map":{"version":3,"sources":["E:/yudan/facerecognition/node_modules/clarifai-nodejs-grpc/src/methods_info.js"],"names":["Protobuf","require","PROTO_PATH","__dirname","filenames","options","keepCase","longs","String","enums","Number","defaults","oneofs","readAppIdAndUserId","request","constructor","Array","e","ids","length","Object","key","hasOwnProperty","value","Error","findAppropriateUrl","name","bestMatchUrl","undefined","bestMatchCount","allFields","bestMatchUrlFields","methodsInfo","extractMethodsInfo","info","appId","userId","availableUrl","availableUrls","allArgumentsTranslated","url","count","urlFields","extractRequiredUrlParameters","field","parts","split","fieldName","fieldValue","replace","push","openings","closes","i","fields","substring","root","Root","loadedRoot","loadSync","methods","nested","clarifai","api","V2","methodName","methodInfo","httpMethod","startsWith","some","s","endsWith","fieldNameParts","console","log","module","exports"],"mappings":"AAAA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,YAAD,CAAxB;;AAEA,MAAMC,UAAU,GAAGC,SAAS,GAAG,WAA/B;AAEA,MAAMC,SAAS,GAAG,CACdF,UAAU,GAAG,wCADC,EAEdA,UAAU,GAAG,mCAFC,EAGdA,UAAU,GAAG,+BAHC,EAIdA,UAAU,GAAG,uCAJC,CAAlB;AAMA,IAAIG,OAAO,GAAG;AACVC,EAAAA,QAAQ,EAAE,IADA;AAEVC,EAAAA,KAAK,EAAEC,MAFG;AAGVC,EAAAA,KAAK,EAAEC,MAHG;AAIVC,EAAAA,QAAQ,EAAE,KAJA;AAKVC,EAAAA,MAAM,EAAE;AALE,CAAd;AASA;;;;AAGA,SAASC,kBAAT,CAA4BC,OAA5B,EAAqC;AACjC,MAAIA,OAAO,CAACC,WAAR,KAAwBC,KAA5B,EAAmC;AAC/B,SAAK,MAAMC,CAAX,IAAgBH,OAAhB,EAAyB;AACrB,YAAMI,GAAG,GAAGL,kBAAkB,CAACI,CAAD,CAA9B;;AACA,UAAIC,GAAG,CAACC,MAAJ,KAAe,CAAnB,EAAsB;AAClB,eAAOD,GAAP;AACH;AACJ;AACJ,GAPD,MAOO,IAAIJ,OAAO,CAACC,WAAR,KAAwBK,MAA5B,EAAoC;AACvC,SAAK,MAAMC,GAAX,IAAkBP,OAAlB,EAA2B;AACvB,UAAI,CAACA,OAAO,CAACQ,cAAR,CAAuBD,GAAvB,CAAL,EAAkC;AAElC,YAAME,KAAK,GAAGT,OAAO,CAACO,GAAD,CAArB;;AACA,UAAIA,GAAG,KAAK,MAAZ,EAAoB;AAChB,YAAIE,KAAK,CAACJ,MAAN,KAAiB,CAArB,EAAwB;AACpB,iBAAO,CAACI,KAAK,CAAC,CAAD,CAAL,CAAS,IAAT,CAAD,EAAiBA,KAAK,CAAC,CAAD,CAAL,CAAS,SAAT,CAAjB,CAAP;AACH,SAFD,MAEO,IAAIA,KAAK,CAACJ,MAAN,KAAiB,CAArB,EAAwB;AAC3B,iBAAO,EAAP;AACH,SAFM,MAEA;AACH,gBAAM,IAAIK,KAAJ,CAAU,+CAAV,CAAN;AACH;AACJ,OARD,MAQO,IAAIH,GAAG,KAAK,UAAZ,EAAwB;AAC3B;AACH;;AACD,YAAMH,GAAG,GAAGL,kBAAkB,CAACU,KAAD,CAA9B;;AACA,UAAIL,GAAG,CAACC,MAAJ,KAAe,CAAnB,EAAsB;AAClB,eAAOD,GAAP;AACH;AACJ;AACJ;;AACD,SAAO,EAAP;AACH;;AAED,SAASO,kBAAT,CAA4BC,IAA5B,EAAkCZ,OAAlC,EAA2C;AACvC,MAAIa,YAAY,GAAGC,SAAnB;AACA,MAAIC,cAAc,GAAG,CAAC,CAAtB;AAEA,MAAIC,SAAS,GAAG,EAAhB;AACA,MAAIC,kBAAkB,GAAGH,SAAzB;AAEA,QAAMI,WAAW,GAAGC,kBAAkB,CAAC7B,SAAD,EAAYC,OAAZ,CAAtC;AAEA,QAAM6B,IAAI,GAAGF,WAAW,CAACN,IAAD,CAAxB;;AACA,MAAI,CAACQ,IAAL,EAAW;AACP,WAAON,SAAP;AACH;;AAED,QAAMV,GAAG,GAAGL,kBAAkB,CAACC,OAAD,CAA9B;AACA,MAAIqB,KAAJ;AACA,MAAIC,MAAJ;;AACA,MAAIlB,GAAG,CAACC,MAAJ,KAAe,CAAnB,EAAsB;AAClBgB,IAAAA,KAAK,GAAGjB,GAAG,CAAC,CAAD,CAAX;AACAkB,IAAAA,MAAM,GAAGlB,GAAG,CAAC,CAAD,CAAZ;AACH,GAHD,MAGO;AACHiB,IAAAA,KAAK,GAAG,IAAR;AACAC,IAAAA,MAAM,GAAG,IAAT;AACH;;AAED,OAAK,MAAMC,YAAX,IAA2BH,IAAI,CAACI,aAAhC,EAA+C;AAC3C,QAAIC,sBAAsB,GAAG,IAA7B;AAEA,QAAIC,GAAG,GAAGH,YAAV;AACA,QAAII,KAAK,GAAG,CAAZ;AACA,QAAIC,SAAS,GAAGC,4BAA4B,CAACH,GAAD,CAA5C;;AACA,SAAK,MAAMI,KAAX,IAAoBF,SAApB,EAA+B;AAC3B,YAAMG,KAAK,GAAGD,KAAK,CAACE,KAAN,CAAY,GAAZ,CAAd;AACA,YAAMC,SAAS,GAAGF,KAAK,CAACA,KAAK,CAAC1B,MAAN,GAAe,CAAhB,CAAvB;AAEA,UAAI6B,UAAJ;;AACA,UAAID,SAAS,KAAK,QAAlB,EAA4B;AACxBC,QAAAA,UAAU,GAAGb,KAAb;AACH,OAFD,MAEO,IAAIY,SAAS,KAAK,SAAlB,EAA6B;AAChC,YAAIX,MAAM,IAAI,IAAd,EAAoB;AAChBY,UAAAA,UAAU,GAAGZ,MAAb;AACH,SAFD,MAEO;AACHY,UAAAA,UAAU,GAAG,IAAb;AACH;AACJ,OANM,MAMA;AACHA,QAAAA,UAAU,GAAGlC,OAAO,CAACiC,SAAD,CAApB;AACH;;AACD,UAAI,CAACC,UAAL,EAAiB;AACbT,QAAAA,sBAAsB,GAAG,KAAzB;AACA;AACH;;AAEDE,MAAAA,KAAK;AAELD,MAAAA,GAAG,GAAGA,GAAG,CAACS,OAAJ,CAAY,MAAML,KAAN,GAAc,GAA1B,EAA+BI,UAA/B,CAAN;AACH;;AAEDlB,IAAAA,SAAS,CAACoB,IAAV,CAAehB,IAAI,CAACI,aAApB;;AAEA,QAAIC,sBAAJ,EAA4B;AACxB,UAAIV,cAAc,GAAGY,KAArB,EAA4B;AACxBd,QAAAA,YAAY,GAAGa,GAAf;AACAT,QAAAA,kBAAkB,GAAGW,SAArB;AACAb,QAAAA,cAAc,GAAGY,KAAjB;AACH;AACJ;AACJ;;AAED,MAAI,CAACd,YAAL,EAAmB;AACf,UAAM,IAAIH,KAAJ,CAAU,0EAA0EM,SAApF,CAAN;AACH;;AAED,SAAO;AAAC,kBAAcI,IAAI,CAAC,YAAD,CAAnB;AAAmC,cAAUP,YAA7C;AAA2D,kBAAcI;AAAzE,GAAP;AACH;;AAGD,SAASY,4BAAT,CAAsCH,GAAtC,EAA2C;AACvC,QAAMW,QAAQ,GAAG,EAAjB;AACA,QAAMC,MAAM,GAAG,EAAf;;AACA,OAAK,IAAIC,CAAC,GAAC,CAAX,EAAcA,CAAC,GAACb,GAAG,CAACrB,MAApB,EAA2BkC,CAAC,EAA5B,EAAgC;AAC5B,QAAIb,GAAG,CAACa,CAAD,CAAH,KAAW,GAAf,EAAoBF,QAAQ,CAACD,IAAT,CAAcG,CAAd;AACpB,QAAIb,GAAG,CAACa,CAAD,CAAH,KAAW,GAAf,EAAoBD,MAAM,CAACF,IAAP,CAAYG,CAAZ;AACvB;;AAED,QAAMC,MAAM,GAAG,EAAf;;AACA,OAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,QAAQ,CAAChC,MAA7B,EAAqCkC,CAAC,EAAtC,EAA0C;AACtCC,IAAAA,MAAM,CAACJ,IAAP,CAAYV,GAAG,CAACe,SAAJ,CAAcJ,QAAQ,CAACE,CAAD,CAAR,GAAc,CAA5B,EAA+BD,MAAM,CAACC,CAAD,CAArC,CAAZ;AACH;;AACD,SAAOC,MAAP;AACH;;AAGD,SAASrB,kBAAT,CAA4B7B,SAA5B,EAAuCC,OAAvC,EAAgD;AAC5C,QAAM2B,WAAW,GAAG,EAApB;AAEA,QAAMwB,IAAI,GAAG,IAAIxD,QAAQ,CAACyD,IAAb,EAAb;AACA,QAAMC,UAAU,GAAGF,IAAI,CAACG,QAAL,CAAcvD,SAAd,EAAyBC,OAAzB,CAAnB;AAEA,QAAMuD,OAAO,GAAGF,UAAU,CAACG,MAAX,CAAkBC,QAAlB,CAA2BD,MAA3B,CAAkCE,GAAlC,CAAsCC,EAAtC,CAAyCJ,OAAzD;;AAEA,OAAK,MAAMK,UAAX,IAAyBL,OAAzB,EAAkC;AAC9B,QAAI,CAACA,OAAO,CAACtC,cAAR,CAAuB2C,UAAvB,CAAL,EAAyC;AAEzC,UAAMC,UAAU,GAAG;AACfC,MAAAA,UAAU,EAAEvC,SADG;AAEfU,MAAAA,aAAa,EAAE;AAFA,KAAnB;AAKA,UAAMjC,OAAO,GAAGuD,OAAO,CAACK,UAAD,CAAP,CAAoB5D,OAApC;;AACA,SAAK,MAAM0C,SAAX,IAAwB1C,OAAxB,EAAiC;AAC7B,UAAI,CAAC0C,SAAS,CAACqB,UAAV,CAAqB,oBAArB,CAAL,EAAiD;;AAEjD,UAAI,CAAC,CAAC,MAAD,EAAS,OAAT,EAAkB,QAAlB,EAA4B,SAA5B,EAAuCC,IAAvC,CAA4CC,CAAC,IAAIvB,SAAS,CAACwB,QAAV,CAAmBD,CAAnB,CAAjD,CAAL,EAA8E;AAC1E;AACA;AACH;;AAED,YAAME,cAAc,GAAGzB,SAAS,CAACD,KAAV,CAAgB,GAAhB,CAAvB;AACAoB,MAAAA,UAAU,CAACC,UAAX,GAAwBK,cAAc,CAACA,cAAc,CAACrD,MAAf,GAAwB,CAAzB,CAAtC;AAEA+C,MAAAA,UAAU,CAAC5B,aAAX,CAAyBY,IAAzB,CAA8B7C,OAAO,CAAC0C,SAAD,CAArC;AACH;;AAED,QAAImB,UAAU,CAACC,UAAf,EAA2B;AACvBnC,MAAAA,WAAW,CAACiC,UAAD,CAAX,GAA0BC,UAA1B;AACH,KAFD,MAEO;AACHO,MAAAA,OAAO,CAACC,GAAR,CAAY,mCAAmCR,UAA/C;AACH;AACJ;;AAED,SAAOlC,WAAP;AACH;;AAED2C,MAAM,CAACC,OAAP,GAAiB;AAACnD,EAAAA;AAAD,CAAjB","sourcesContent":["const Protobuf = require(\"protobufjs\");\n\nconst PROTO_PATH = __dirname + \"/../proto\";\n\nconst filenames = [\n    PROTO_PATH + \"/clarifai/api/status/status_code.proto\",\n    PROTO_PATH + \"/clarifai/api/status/status.proto\",\n    PROTO_PATH + \"/clarifai/api/resources.proto\",\n    PROTO_PATH + \"/clarifai/api/service_processed.proto\",\n];\nlet options = {\n    keepCase: true,\n    longs: String,\n    enums: Number,\n    defaults: false,\n    oneofs: true\n};\n\n\n/*\n * This function extracts the app_id and user_id values from the request object, or returns an empty array.\n */\nfunction readAppIdAndUserId(request) {\n    if (request.constructor === Array) {\n        for (const e of request) {\n            const ids = readAppIdAndUserId(e);\n            if (ids.length === 2) {\n                return ids;\n            }\n        }\n    } else if (request.constructor === Object) {\n        for (const key in request) {\n            if (!request.hasOwnProperty(key)) continue;\n\n            const value = request[key];\n            if (key === \"apps\") {\n                if (value.length === 1) {\n                    return [value[0][\"id\"], value[0][\"user_id\"]]\n                } else if (value.length === 0) {\n                    return [];\n                } else {\n                    throw new Error(\"The request supports specifying only one app.\")\n                }\n            } else if (key === \"metadata\") {\n                continue;\n            }\n            const ids = readAppIdAndUserId(value);\n            if (ids.length === 2) {\n                return ids;\n            }\n        }\n    }\n    return [];\n}\n\nfunction findAppropriateUrl(name, request) {\n    let bestMatchUrl = undefined;\n    let bestMatchCount = -1;\n\n    let allFields = [];\n    let bestMatchUrlFields = undefined;\n\n    const methodsInfo = extractMethodsInfo(filenames, options);\n\n    const info = methodsInfo[name];\n    if (!info) {\n        return undefined;\n    }\n\n    const ids = readAppIdAndUserId(request);\n    let appId;\n    let userId;\n    if (ids.length === 2) {\n        appId = ids[0];\n        userId = ids[1];\n    } else {\n        appId = null;\n        userId = null;\n    }\n\n    for (const availableUrl of info.availableUrls) {\n        let allArgumentsTranslated = true;\n\n        let url = availableUrl;\n        let count = 0;\n        let urlFields = extractRequiredUrlParameters(url);\n        for (const field of urlFields) {\n            const parts = field.split(\".\");\n            const fieldName = parts[parts.length - 1];\n\n            let fieldValue;\n            if (fieldName === \"app_id\") {\n                fieldValue = appId\n            } else if (fieldName === \"user_id\") {\n                if (userId != null) {\n                    fieldValue = userId;\n                } else {\n                    fieldValue = \"me\";\n                }\n            } else {\n                fieldValue = request[fieldName];\n            }\n            if (!fieldValue) {\n                allArgumentsTranslated = false;\n                break;\n            }\n\n            count++;\n\n            url = url.replace(\"{\" + field + \"}\", fieldValue);\n        }\n\n        allFields.push(info.availableUrls);\n\n        if (allArgumentsTranslated) {\n            if (bestMatchCount < count) {\n                bestMatchUrl = url;\n                bestMatchUrlFields = urlFields;\n                bestMatchCount = count;\n            }\n        }\n    }\n\n    if (!bestMatchUrl) {\n        throw new Error(\"You must set one case of the following fields in your request proto: \" + allFields);\n    }\n\n    return {\"httpMethod\": info[\"httpMethod\"], \"subUrl\": bestMatchUrl, \"usedFields\": bestMatchUrlFields};\n}\n\n\nfunction extractRequiredUrlParameters(url) {\n    const openings = [];\n    const closes = [];\n    for (let i=0; i<url.length;i++) {\n        if (url[i] === \"{\") openings.push(i);\n        if (url[i] === \"}\") closes.push(i);\n    }\n\n    const fields = [];\n    for (let i = 0; i < openings.length; i++) {\n        fields.push(url.substring(openings[i] + 1, closes[i]));\n    }\n    return fields;\n}\n\n\nfunction extractMethodsInfo(filenames, options) {\n    const methodsInfo = {};\n\n    const root = new Protobuf.Root();\n    const loadedRoot = root.loadSync(filenames, options);\n\n    const methods = loadedRoot.nested.clarifai.nested.api.V2.methods;\n\n    for (const methodName in methods) {\n        if (!methods.hasOwnProperty(methodName)) continue;\n\n        const methodInfo = {\n            httpMethod: undefined,\n            availableUrls: [],\n        };\n\n        const options = methods[methodName].options;\n        for (const fieldName in options) {\n            if (!fieldName.startsWith(\"(google.api.http).\")) continue;\n\n            if (![\".get\", \".post\", \".patch\", \".delete\"].some(s => fieldName.endsWith(s))) {\n                // This field doesn't describe a HTTP endpoint.\n                continue;\n            }\n\n            const fieldNameParts = fieldName.split(\".\");\n            methodInfo.httpMethod = fieldNameParts[fieldNameParts.length - 1];\n\n            methodInfo.availableUrls.push(options[fieldName]);\n        }\n\n        if (methodInfo.httpMethod) {\n            methodsInfo[methodName] = methodInfo;\n        } else {\n            console.log(\"Warning, strange method info: \" + methodInfo);\n        }\n    }\n\n    return methodsInfo;\n}\n\nmodule.exports = {findAppropriateUrl};\n"]},"metadata":{},"sourceType":"script"}